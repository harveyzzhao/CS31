# 
---------------------
CS31 Project Recap
---------------------
Hello visitor,

As the first quarter at UCLA draws to an end, I feel the obligation to share some thoughts and tips for you who plan or is already taking CS31. 
///////////////////////////////////////////////////////
///////////////////course overview/////////////////////
///////////////////////////////////////////////////////
CS31, as you have probably heard, is a well-designed introductory course in Computer Science even for those of you who had very little background in programming. Professor Smallberg intentionally designed a gentle learning curve throughout the course, so that if you are stuck in one concept (for me, it was pointers and applications of Object-oriented programming), you will have ample time to ask your geeky friends or geeky TAs/Professor about a problem. I know many of you may feel intimidated to approach your classmates or TAs, but just remember that they all came from the same phase - a struggling, and timid beginner as you are right now, and they won't be happier if you go and ask them about the GENERAL APPROACH/ big ideas behind your problem.

///////////////////////////////////////////////////////
//////////////How to approach projects/////////////////
///////////////////////////////////////////////////////
The grading structure may come off as unconventional to a lot of you, who were used to final taking up 50+% of the grade; in fact, this course is all about NOT PROCRASTINATING and finish your weekly projects on time. In fact, the 7 projects you will do consisted of 66% of the final mark this year. With all that being said, it is important to set deadlines for each project and be a go-getter starting NOW. You've made it to the glamorous UCLA, and our future all depend on your success starting from this course. 

So if projects are so important, where should I start?  The general frameworks (non-essential, filling code) will be already given by the time you take on the task, so just focus on applying the concepts you just learned in the past 1 - 2 weeks to solve this problem. Now, I'm going to give you a very time-proof coding procedure that you more than likely would adopt for the onwards of your programming career. 

You and your friend Becca are taking a once-in-a-lifetime-trip to Death Valley, when you suddenly heard a bunch of people yelping and crying for help in the distance. You and Becca ran towards the sound, and you saw another tourist fainted in the shade! Luckily, you have been trained to rescue and save people in wilderness and you had a first aid kit on you. What would you do?

Seeing all those people yelling but doing nothing, you decide that it's not time to get emotional. You quickly schemed a rudimentary plan inside your smart lil head: 
  - I should tell the crowd that I have relevant certificates and ask for the patient or his family's approval to inspect his ailment. 
  - If I gained the patient's permission, take a look to see what's going on.
    - check vitals 
       - airways, 
        if it is normal, proceed to breathing;
        elsewise, free airway blockage immediately by putting him into the recovery position/check where the blockage is at.
        ...
       - breathing, 
        if it is normal, proceed to circulation...
       - circulation
        ...
  - elsewise, suggest them a formulated treatment plan and offer them the first aid kit.

You should kind of get how you would resolve an emergency situation like this. SO WHAT?
This is EXACTLY how you would solve a programming challenge as well! If you are asked to sort a list of customizable mannequin objects in the developement of a game, say Minecraft, you would come up with this plan, called PSEUDOCODE, before you approach this problem. ALWAYS HAVE PSEUDOCODE BEFORE YOU WRITE A SINGLE LINE OF CODE.

Then, you would implement your program in "blocks", blocks of codes that come together to achieve a noticeable function in the program. Everytime you finish building a part, make sure to TEST IT WITH DIFFERENT CASES to prevent having a clusterfuck of compiler errors, or worse, logic errors at the end of your program. It's not going to take extra time, trust me!

If you are finished with your program, don't be happy this early. They say that even a good programmer spend half of his time actually DEBUGGING. Be ready to embrace the struggle of satisfying every one of your cases. Be sure to write a bunch of corner cases: cases that is out of the ordinary but extremely dodgy to catch, in your list of debugging cases.

These folders are the projects we've gone through in Fall 2021 Smallberg's class. 

///////////////////////////////////////////////////
/////////////////Course outline////////////////////
///////////////////////////////////////////////////

The course was taught in C++, and we have gone through these concepts: (the portions enclosed with <> are recommended to learn but not covered in class)
- Programming standards (style - commenting, whitespace, newline..., debugging - using debugger / using cout, unit testing, building incrementally)
- Fundamentals of programming (history, workings of ENIAC & modern computer)
- Basic Data Types (int, float, double, boolean, char...)
- Advanced/Derived Data Types (arrays, vectors, applications - cstrings, c++ strings, < vectors & singly linked lists in classes >)
- Control Flow (if statements, do while / while loop, for loop, short circuit evaluation...)
- Functions (preprocessors, declaration & initialization, function name overloading, scope of variable/ function, return types, public & private functions -> classes, accessors and mutators...)
- pointers (passing by value vs. reference, c pointer operators, prevention of memory leaks, writing arrays/vectors with pointers)
- Object-oriented programming (grouping data using struct and classes, intro to objects, inline member functions, constructors <-> destructors)

///////////////////////////////////////////////////
/////////////////Project scores////////////////////
///////////////////////////////////////////////////
The projects, however, are focused primarily on one topic at a time. Here are my scores for each project, serving as a benchmark for you to reference.
Project 1: 100 / 100
Project 2: 98 / 100
Project 3: 100 / 100
Project 4: 97 / 100
Project 5: 83 / 100
Project 6: 92 / 100 (rather, a set of problems, not a streamlined program)
Project 7: 100 / 100

Lastly, I wish you the best embarking on this once-in-a-lifetime journey to the most promising and revolutionary field of study!

Sincerely,
Harvey Zhao
